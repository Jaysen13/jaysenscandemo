package com.springboot.springbootdemo.controller;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.springboot.springbootdemo.util.AESUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.ModelAndView;

@RestController
public class VulnerabilityController {
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityController.class);

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 首页
    @GetMapping("/")
    public ModelAndView index() {
        return new ModelAndView("index");
    }

    // 1. Fastjson反序列化漏洞
    @PostMapping("/vuln/fastjson")
    public String fastjsonVuln(@RequestBody String json) {
        try {
            JSONObject obj = JSON.parseObject(json);
            return "Fastjson解析结果: " + obj.toJSONString();
        } catch (Exception e) {
            return "解析异常: " + e.getMessage();
        }
    }

    // 2. Log4j反序列化漏洞
    @PostMapping("/vuln/log4j")
    public String log4jVuln(@RequestParam String input) {
        // 危险操作：直接将用户输入写入日志
        logger.error("用户输入内容: " + input);
        return "Log4j处理完成";
    }

    // 3. AES加密的Fastjson反序列化漏洞
    @PostMapping("/vuln/aes/fastjson")
    public String aesFastjsonVuln(@RequestParam String encryptedJson) {
        try {
            // 解密用户输入
            String json = AESUtils.decrypt(encryptedJson);
            // 危险操作：使用Fastjson解析解密后的内容
            JSONObject obj = JSON.parseObject(json);
            return "AES+Fastjson解析结果: " + obj.toJSONString();
        } catch (Exception e) {
            return "解析异常: " + e.getMessage();
        }
    }

    // 4. AES加密的Log4j反序列化漏洞
    @PostMapping("/vuln/aes/log4j")
    public String aesLog4jVuln(@RequestParam String encryptedInput) {
        try {
            // 解密用户输入
            String input = AESUtils.decrypt(encryptedInput);
            // 危险操作：将解密后的内容写入日志
            logger.error("AES解密后内容: " + input);
            return "AES+Log4j处理完成";
        } catch (Exception e) {
            return "处理异常: " + e.getMessage();
        }
    }

    // 5. AES加密的SQL注入登录点
    @PostMapping("/vuln/aes/login")
    public String aesLoginVuln(@RequestParam String encryptedUser, @RequestParam String encryptedPass) {
        try {
            // 解密用户输入
            String username = AESUtils.decrypt(encryptedUser);
            String password = AESUtils.decrypt(encryptedPass);

            username = java.net.URLDecoder.decode(username, "UTF-8");
            password = java.net.URLDecoder.decode(password, "UTF-8");

            String sql = "SELECT COUNT(*) FROM users WHERE username = '" + username + "' AND password = '" + password + "'";
            logger.info("执行SQL: " + sql);

            // 执行查询
            int count = jdbcTemplate.queryForObject(sql, Integer.class);

            return count > 0 ? "登录成功" : "登录失败";
        } catch (Exception e) {
            return "登录异常: " + e.getMessage();
        }
    }
}